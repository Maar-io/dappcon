{
  "magicNumber": 1635018093,
  "metadata": {
    "v13": {
      "modules": [
        {
          "name": "System",
          "storage": {
            "prefix": "System",
            "items": [
              {
                "name": "Account",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Blake2_128Concat",
                    "key": "AccountId",
                    "value": "AccountInfo",
                    "linked": false
                  }
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
                "docs": [
                  " The full account information for a particular account ID."
                ]
              },
              {
                "name": "ExtrinsicCount",
                "modifier": "Optional",
                "type": {
                  "plain": "u32"
                },
                "fallback": "0x00",
                "docs": [
                  " Total extrinsics count for the current block."
                ]
              },
              {
                "name": "BlockWeight",
                "modifier": "Default",
                "type": {
                  "plain": "ConsumedWeight"
                },
                "fallback": "0x000000000000000000000000000000000000000000000000",
                "docs": [
                  " The current weight for the block."
                ]
              },
              {
                "name": "AllExtrinsicsLen",
                "modifier": "Optional",
                "type": {
                  "plain": "u32"
                },
                "fallback": "0x00",
                "docs": [
                  " Total length (in bytes) for all extrinsics put together, for the current block."
                ]
              },
              {
                "name": "BlockHash",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Twox64Concat",
                    "key": "BlockNumber",
                    "value": "Hash",
                    "linked": false
                  }
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "docs": [
                  " Map of block numbers to block hashes."
                ]
              },
              {
                "name": "ExtrinsicData",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Twox64Concat",
                    "key": "u32",
                    "value": "Bytes",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Extrinsics data for the current block (maps an extrinsic's index to its data)."
                ]
              },
              {
                "name": "Number",
                "modifier": "Default",
                "type": {
                  "plain": "BlockNumber"
                },
                "fallback": "0x00000000",
                "docs": [
                  " The current block number being processed. Set by `execute_block`."
                ]
              },
              {
                "name": "ParentHash",
                "modifier": "Default",
                "type": {
                  "plain": "Hash"
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "docs": [
                  " Hash of the previous block."
                ]
              },
              {
                "name": "Digest",
                "modifier": "Default",
                "type": {
                  "plain": "DigestOf"
                },
                "fallback": "0x00",
                "docs": [
                  " Digest of the current block, also part of the block header."
                ]
              },
              {
                "name": "Events",
                "modifier": "Default",
                "type": {
                  "plain": "Vec<EventRecord>"
                },
                "fallback": "0x00",
                "docs": [
                  " Events deposited for the current block."
                ]
              },
              {
                "name": "EventCount",
                "modifier": "Default",
                "type": {
                  "plain": "EventIndex"
                },
                "fallback": "0x00000000",
                "docs": [
                  " The number of events in the `Events<T>` list."
                ]
              },
              {
                "name": "EventTopics",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Blake2_128Concat",
                    "key": "Hash",
                    "value": "Vec<(BlockNumber,EventIndex)>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Mapping between a topic (represented by T::Hash) and a vector of indexes",
                  " of events in the `<Events<T>>` list.",
                  "",
                  " All topic vectors have deterministic storage locations depending on the topic. This",
                  " allows light-clients to leverage the changes trie storage tracking mechanism and",
                  " in case of changes fetch the list of events of interest.",
                  "",
                  " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just",
                  " the `EventIndex` then in case if the topic has the same contents on the next block",
                  " no notification will be triggered thus the event might be lost."
                ]
              },
              {
                "name": "LastRuntimeUpgrade",
                "modifier": "Optional",
                "type": {
                  "plain": "LastRuntimeUpgradeInfo"
                },
                "fallback": "0x00",
                "docs": [
                  " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."
                ]
              },
              {
                "name": "UpgradedToU32RefCount",
                "modifier": "Default",
                "type": {
                  "plain": "bool"
                },
                "fallback": "0x00",
                "docs": [
                  " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."
                ]
              },
              {
                "name": "UpgradedToTripleRefCount",
                "modifier": "Default",
                "type": {
                  "plain": "bool"
                },
                "fallback": "0x00",
                "docs": [
                  " True if we have upgraded so that AccountInfo contains three types of `RefCount`. False",
                  " (default) if not."
                ]
              },
              {
                "name": "ExecutionPhase",
                "modifier": "Optional",
                "type": {
                  "plain": "Phase"
                },
                "fallback": "0x00",
                "docs": [
                  " The execution phase of the block."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "fill_block",
              "args": [
                {
                  "name": "_ratio",
                  "type": "Perbill"
                }
              ],
              "docs": [
                " A dispatch that will fill the block weight up to the given ratio."
              ]
            },
            {
              "name": "remark",
              "args": [
                {
                  "name": "_remark",
                  "type": "Bytes"
                }
              ],
              "docs": [
                " Make some on-chain remark.",
                "",
                " # <weight>",
                " - `O(1)`",
                " # </weight>"
              ]
            },
            {
              "name": "set_heap_pages",
              "args": [
                {
                  "name": "pages",
                  "type": "u64"
                }
              ],
              "docs": [
                " Set the number of pages in the WebAssembly environment's heap.",
                "",
                " # <weight>",
                " - `O(1)`",
                " - 1 storage write.",
                " - Base Weight: 1.405 Âµs",
                " - 1 write to HEAP_PAGES",
                " # </weight>"
              ]
            },
            {
              "name": "set_code",
              "args": [
                {
                  "name": "code",
                  "type": "Bytes"
                }
              ],
              "docs": [
                " Set the new runtime code.",
                "",
                " # <weight>",
                " - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`",
                " - 1 storage write (codec `O(C)`).",
                " - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is expensive).",
                " - 1 event.",
                " The weight of this function is dependent on the runtime, but generally this is very expensive.",
                " We will treat this as a full block.",
                " # </weight>"
              ]
            },
            {
              "name": "set_code_without_checks",
              "args": [
                {
                  "name": "code",
                  "type": "Bytes"
                }
              ],
              "docs": [
                " Set the new runtime code without doing any checks of the given `code`.",
                "",
                " # <weight>",
                " - `O(C)` where `C` length of `code`",
                " - 1 storage write (codec `O(C)`).",
                " - 1 event.",
                " The weight of this function is dependent on the runtime. We will treat this as a full block.",
                " # </weight>"
              ]
            },
            {
              "name": "set_changes_trie_config",
              "args": [
                {
                  "name": "changes_trie_config",
                  "type": "Option<ChangesTrieConfiguration>"
                }
              ],
              "docs": [
                " Set the new changes trie configuration.",
                "",
                " # <weight>",
                " - `O(1)`",
                " - 1 storage write or delete (codec `O(1)`).",
                " - 1 call to `deposit_log`: Uses `append` API, so O(1)",
                " - Base Weight: 7.218 Âµs",
                " - DB Weight:",
                "     - Writes: Changes Trie, System Digest",
                " # </weight>"
              ]
            },
            {
              "name": "set_storage",
              "args": [
                {
                  "name": "items",
                  "type": "Vec<KeyValue>"
                }
              ],
              "docs": [
                " Set some items of storage.",
                "",
                " # <weight>",
                " - `O(I)` where `I` length of `items`",
                " - `I` storage writes (`O(1)`).",
                " - Base Weight: 0.568 * i Âµs",
                " - Writes: Number of items",
                " # </weight>"
              ]
            },
            {
              "name": "kill_storage",
              "args": [
                {
                  "name": "keys",
                  "type": "Vec<Key>"
                }
              ],
              "docs": [
                " Kill some items from storage.",
                "",
                " # <weight>",
                " - `O(IK)` where `I` length of `keys` and `K` length of one key",
                " - `I` storage deletions.",
                " - Base Weight: .378 * i Âµs",
                " - Writes: Number of items",
                " # </weight>"
              ]
            },
            {
              "name": "kill_prefix",
              "args": [
                {
                  "name": "prefix",
                  "type": "Key"
                },
                {
                  "name": "_subkeys",
                  "type": "u32"
                }
              ],
              "docs": [
                " Kill all storage items with a key that starts with the given prefix.",
                "",
                " **NOTE:** We rely on the Root origin to provide us the number of subkeys under",
                " the prefix we are removing to accurately calculate the weight of this function.",
                "",
                " # <weight>",
                " - `O(P)` where `P` amount of keys with prefix `prefix`",
                " - `P` storage deletions.",
                " - Base Weight: 0.834 * P Âµs",
                " - Writes: Number of subkeys + 1",
                " # </weight>"
              ]
            },
            {
              "name": "remark_with_event",
              "args": [
                {
                  "name": "remark",
                  "type": "Bytes"
                }
              ],
              "docs": [
                " Make some on-chain remark and emit event.",
                "",
                " # <weight>",
                " - `O(b)` where b is the length of the remark.",
                " - 1 event.",
                " # </weight>"
              ]
            }
          ],
          "events": [
            {
              "name": "ExtrinsicSuccess",
              "args": [
                "DispatchInfo"
              ],
              "docs": [
                " An extrinsic completed successfully. \\[info\\]"
              ]
            },
            {
              "name": "ExtrinsicFailed",
              "args": [
                "DispatchError",
                "DispatchInfo"
              ],
              "docs": [
                " An extrinsic failed. \\[error, info\\]"
              ]
            },
            {
              "name": "CodeUpdated",
              "args": [],
              "docs": [
                " `:code` was updated."
              ]
            },
            {
              "name": "NewAccount",
              "args": [
                "AccountId"
              ],
              "docs": [
                " A new \\[account\\] was created."
              ]
            },
            {
              "name": "KilledAccount",
              "args": [
                "AccountId"
              ],
              "docs": [
                " An \\[account\\] was reaped."
              ]
            },
            {
              "name": "Remarked",
              "args": [
                "AccountId",
                "Hash"
              ],
              "docs": [
                " On on-chain remark happened. \\[origin, remark_hash\\]"
              ]
            }
          ],
          "constants": [
            {
              "name": "BlockWeights",
              "type": "BlockWeights",
              "value": "0x00f2052a010000000010a5d4e8000000405973070000000001c08a914f970000000100cc7b9fae000000010000000000000000405973070000000001c0ceba84d1000000010010a5d4e800000001004429353a0000004059730700000000000000",
              "docs": [
                " Block & extrinsics weights: base values and limits."
              ]
            },
            {
              "name": "BlockLength",
              "type": "BlockLength",
              "value": "0x00003c000000500000005000",
              "docs": [
                " The maximum length of a block (in bytes)."
              ]
            },
            {
              "name": "BlockHashCount",
              "type": "BlockNumber",
              "value": "0x60090000",
              "docs": [
                " Maximum number of block number to block hash mappings to keep (oldest pruned first)."
              ]
            },
            {
              "name": "DbWeight",
              "type": "RuntimeDbWeight",
              "value": "0x40787d010000000000e1f50500000000",
              "docs": [
                " The weight of runtime database operations the runtime can invoke."
              ]
            },
            {
              "name": "Version",
              "type": "RuntimeVersion",
              "value": "0x2c61737461722d6c6f63616c2c61737461722d6c6f63616c01000000010000000100000030df6acb689907609b0300000037e397fc7c91f5e40100000040fe3ad401f8959a05000000d2bc9897eed08f1503000000f78b278be53f454c02000000dd718d5cc53262d401000000ab3c0572291feb8b01000000ed99c5acb25eedf503000000bc9d89904f5b923f0100000037c8bb1350a9a2a801000000582211f65bb14b890100000068b66ba122c93fa70100000001000000",
              "docs": [
                " Get the chain's current version."
              ]
            },
            {
              "name": "SS58Prefix",
              "type": "u16",
              "value": "0x0500",
              "docs": [
                " The designated SS85 prefix of this chain.",
                "",
                " This replaces the \"ss58Format\" property declared in the chain spec. Reason is",
                " that the runtime should know about the prefix in order to make use of it as",
                " an identifier of the chain."
              ]
            }
          ],
          "errors": [
            {
              "name": "InvalidSpecName",
              "docs": [
                " The name of specification does not match between the current runtime",
                " and the new runtime."
              ]
            },
            {
              "name": "SpecVersionNeedsToIncrease",
              "docs": [
                " The specification version is not allowed to decrease between the current runtime",
                " and the new runtime."
              ]
            },
            {
              "name": "FailedToExtractRuntimeVersion",
              "docs": [
                " Failed to extract the runtime version from the new runtime.",
                "",
                " Either calling `Core_version` or decoding `RuntimeVersion` failed."
              ]
            },
            {
              "name": "NonDefaultComposite",
              "docs": [
                " Suicide called when the account has non-default composite data."
              ]
            },
            {
              "name": "NonZeroRefCount",
              "docs": [
                " There is a non-zero reference count preventing the account from being purged."
              ]
            }
          ],
          "index": 0
        },
        {
          "name": "Timestamp",
          "storage": {
            "prefix": "Timestamp",
            "items": [
              {
                "name": "Now",
                "modifier": "Default",
                "type": {
                  "plain": "Moment"
                },
                "fallback": "0x0000000000000000",
                "docs": [
                  " Current time for the current block."
                ]
              },
              {
                "name": "DidUpdate",
                "modifier": "Default",
                "type": {
                  "plain": "bool"
                },
                "fallback": "0x00",
                "docs": [
                  " Did the timestamp get updated in this block?"
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "set",
              "args": [
                {
                  "name": "now",
                  "type": "Compact<Moment>"
                }
              ],
              "docs": [
                " Set the current time.",
                "",
                " This call should be invoked exactly once per block. It will panic at the finalization",
                " phase, if this call hasn't been invoked by that time.",
                "",
                " The timestamp should be greater than the previous one by the amount specified by",
                " `MinimumPeriod`.",
                "",
                " The dispatch origin for this call must be `Inherent`.",
                "",
                " # <weight>",
                " - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)",
                " - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in `on_finalize`)",
                " - 1 event handler `on_timestamp_set`. Must be `O(1)`.",
                " # </weight>"
              ]
            }
          ],
          "events": null,
          "constants": [
            {
              "name": "MinimumPeriod",
              "type": "Moment",
              "value": "0xe803000000000000",
              "docs": [
                " The minimum period between blocks. Beware that this is different to the *expected* period",
                " that the block production apparatus provides. Your chosen consensus system will generally",
                " work with this to determine a sensible block time. e.g. For Aura, it will be double this",
                " period on default settings."
              ]
            }
          ],
          "errors": [],
          "index": 1
        },
        {
          "name": "RandomnessCollectiveFlip",
          "storage": {
            "prefix": "RandomnessCollectiveFlip",
            "items": [
              {
                "name": "RandomMaterial",
                "modifier": "Default",
                "type": {
                  "plain": "Vec<Hash>"
                },
                "fallback": "0x00",
                "docs": [
                  " Series of block headers from the last 81 blocks that acts as random seed material. This",
                  " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of",
                  " the oldest hash."
                ]
              }
            ]
          },
          "calls": null,
          "events": null,
          "constants": [],
          "errors": [],
          "index": 2
        },
        {
          "name": "Aura",
          "storage": null,
          "calls": null,
          "events": null,
          "constants": [],
          "errors": [],
          "index": 3
        },
        {
          "name": "Grandpa",
          "storage": {
            "prefix": "Grandpa",
            "items": [
              {
                "name": "State",
                "modifier": "Default",
                "type": {
                  "plain": "StoredState"
                },
                "fallback": "0x00",
                "docs": [
                  " State of the current authority set."
                ]
              },
              {
                "name": "PendingChange",
                "modifier": "Optional",
                "type": {
                  "plain": "StoredPendingChange"
                },
                "fallback": "0x00",
                "docs": [
                  " Pending change: (signaled at, scheduled change)."
                ]
              },
              {
                "name": "NextForced",
                "modifier": "Optional",
                "type": {
                  "plain": "BlockNumber"
                },
                "fallback": "0x00",
                "docs": [
                  " next block number where we can force a change."
                ]
              },
              {
                "name": "Stalled",
                "modifier": "Optional",
                "type": {
                  "plain": "(BlockNumber,BlockNumber)"
                },
                "fallback": "0x00",
                "docs": [
                  " `true` if we are currently stalled."
                ]
              },
              {
                "name": "CurrentSetId",
                "modifier": "Default",
                "type": {
                  "plain": "SetId"
                },
                "fallback": "0x0000000000000000",
                "docs": [
                  " The number of changes (both in terms of keys and underlying economic responsibilities)",
                  " in the \"set\" of Grandpa validators from genesis."
                ]
              },
              {
                "name": "SetIdSession",
                "modifier": "Optional",
                "type": {
                  "map": {
                    "hasher": "Twox64Concat",
                    "key": "SetId",
                    "value": "SessionIndex",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " A mapping from grandpa set ID to the index of the *most recent* session for which its",
                  " members were responsible.",
                  "",
                  " TWOX-NOTE: `SetId` is not under user control."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "report_equivocation",
              "args": [
                {
                  "name": "equivocation_proof",
                  "type": "GrandpaEquivocationProof"
                },
                {
                  "name": "key_owner_proof",
                  "type": "KeyOwnerProof"
                }
              ],
              "docs": [
                " Report voter equivocation/misbehavior. This method will verify the",
                " equivocation proof and validate the given key ownership proof",
                " against the extracted offender. If both are valid, the offence",
                " will be reported."
              ]
            },
            {
              "name": "report_equivocation_unsigned",
              "args": [
                {
                  "name": "equivocation_proof",
                  "type": "GrandpaEquivocationProof"
                },
                {
                  "name": "key_owner_proof",
                  "type": "KeyOwnerProof"
                }
              ],
              "docs": [
                " Report voter equivocation/misbehavior. This method will verify the",
                " equivocation proof and validate the given key ownership proof",
                " against the extracted offender. If both are valid, the offence",
                " will be reported.",
                "",
                " This extrinsic must be called unsigned and it is expected that only",
                " block authors will call it (validated in `ValidateUnsigned`), as such",
                " if the block author is defined it will be defined as the equivocation",
                " reporter."
              ]
            },
            {
              "name": "note_stalled",
              "args": [
                {
                  "name": "delay",
                  "type": "BlockNumber"
                },
                {
                  "name": "best_finalized_block_number",
                  "type": "BlockNumber"
                }
              ],
              "docs": [
                " Note that the current authority set of the GRANDPA finality gadget has",
                " stalled. This will trigger a forced authority set change at the beginning",
                " of the next session, to be enacted `delay` blocks after that. The delay",
                " should be high enough to safely assume that the block signalling the",
                " forced change will not be re-orged (e.g. 1000 blocks). The GRANDPA voters",
                " will start the new authority set using the given finalized block as base.",
                " Only callable by root."
              ]
            }
          ],
          "events": [
            {
              "name": "NewAuthorities",
              "args": [
                "AuthorityList"
              ],
              "docs": [
                " New authority set has been applied. \\[authority_set\\]"
              ]
            },
            {
              "name": "Paused",
              "args": [],
              "docs": [
                " Current authority set has been paused."
              ]
            },
            {
              "name": "Resumed",
              "args": [],
              "docs": [
                " Current authority set has been resumed."
              ]
            }
          ],
          "constants": [],
          "errors": [
            {
              "name": "PauseFailed",
              "docs": [
                " Attempt to signal GRANDPA pause when the authority set isn't live",
                " (either paused or already pending pause)."
              ]
            },
            {
              "name": "ResumeFailed",
              "docs": [
                " Attempt to signal GRANDPA resume when the authority set isn't paused",
                " (either live or already pending resume)."
              ]
            },
            {
              "name": "ChangePending",
              "docs": [
                " Attempt to signal GRANDPA change with one already pending."
              ]
            },
            {
              "name": "TooSoon",
              "docs": [
                " Cannot signal forced change so soon after last."
              ]
            },
            {
              "name": "InvalidKeyOwnershipProof",
              "docs": [
                " A key ownership proof provided as part of an equivocation report is invalid."
              ]
            },
            {
              "name": "InvalidEquivocationProof",
              "docs": [
                " An equivocation proof provided as part of an equivocation report is invalid."
              ]
            },
            {
              "name": "DuplicateOffenceReport",
              "docs": [
                " A given equivocation report is valid but already previously reported."
              ]
            }
          ],
          "index": 4
        },
        {
          "name": "Balances",
          "storage": {
            "prefix": "Balances",
            "items": [
              {
                "name": "TotalIssuance",
                "modifier": "Default",
                "type": {
                  "plain": "Balance"
                },
                "fallback": "0x00000000000000000000000000000000",
                "docs": [
                  " The total units issued in the system."
                ]
              },
              {
                "name": "Account",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Blake2_128Concat",
                    "key": "AccountId",
                    "value": "AccountData",
                    "linked": false
                  }
                },
                "fallback": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
                "docs": [
                  " The balance of an account.",
                  "",
                  " NOTE: This is only used in the case that this pallet is used to store balances."
                ]
              },
              {
                "name": "Locks",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Blake2_128Concat",
                    "key": "AccountId",
                    "value": "Vec<BalanceLock>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Any liquidity locks on some account balances.",
                  " NOTE: Should only be accessed when setting, changing and freeing a lock."
                ]
              },
              {
                "name": "Reserves",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Blake2_128Concat",
                    "key": "AccountId",
                    "value": "Vec<ReserveData>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Named reserves on some account balances."
                ]
              },
              {
                "name": "StorageVersion",
                "modifier": "Default",
                "type": {
                  "plain": "Releases"
                },
                "fallback": "0x00",
                "docs": [
                  " Storage version of the pallet.",
                  "",
                  " This is set to v2.0.0 for new networks."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "transfer",
              "args": [
                {
                  "name": "dest",
                  "type": "LookupSource"
                },
                {
                  "name": "value",
                  "type": "Compact<Balance>"
                }
              ],
              "docs": [
                " Transfer some liquid free balance to another account.",
                "",
                " `transfer` will set the `FreeBalance` of the sender and receiver.",
                " It will decrease the total issuance of the system by the `TransferFee`.",
                " If the sender's account is below the existential deposit as a result",
                " of the transfer, the account will be reaped.",
                "",
                " The dispatch origin for this call must be `Signed` by the transactor.",
                "",
                " # <weight>",
                " - Dependent on arguments but not critical, given proper implementations for",
                "   input config types. See related functions below.",
                " - It contains a limited number of reads and writes internally and no complex computation.",
                "",
                " Related functions:",
                "",
                "   - `ensure_can_withdraw` is always called internally but has a bounded complexity.",
                "   - Transferring balances to accounts that did not exist before will cause",
                "      `T::OnNewAccount::on_new_account` to be called.",
                "   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.",
                "   - `transfer_keep_alive` works the same way as `transfer`, but has an additional",
                "     check that the transfer will not kill the origin account.",
                " ---------------------------------",
                " - Base Weight: 73.64 Âµs, worst case scenario (account created, account removed)",
                " - DB Weight: 1 Read and 1 Write to destination account",
                " - Origin account is already in memory, so no DB operations for them.",
                " # </weight>"
              ]
            },
            {
              "name": "set_balance",
              "args": [
                {
                  "name": "who",
                  "type": "LookupSource"
                },
                {
                  "name": "new_free",
                  "type": "Compact<Balance>"
                },
                {
                  "name": "new_reserved",
                  "type": "Compact<Balance>"
                }
              ],
              "docs": [
                " Set the balances of a given account.",
                "",
                " This will alter `FreeBalance` and `ReservedBalance` in storage. it will",
                " also decrease the total issuance of the system (`TotalIssuance`).",
                " If the new free or reserved balance is below the existential deposit,",
                " it will reset the account nonce (`frame_system::AccountNonce`).",
                "",
                " The dispatch origin for this call is `root`.",
                "",
                " # <weight>",
                " - Independent of the arguments.",
                " - Contains a limited number of reads and writes.",
                " ---------------------",
                " - Base Weight:",
                "     - Creating: 27.56 Âµs",
                "     - Killing: 35.11 Âµs",
                " - DB Weight: 1 Read, 1 Write to `who`",
                " # </weight>"
              ]
            },
            {
              "name": "force_transfer",
              "args": [
                {
                  "name": "source",
                  "type": "LookupSource"
                },
                {
                  "name": "dest",
                  "type": "LookupSource"
                },
                {
                  "name": "value",
                  "type": "Compact<Balance>"
                }
              ],
              "docs": [
                " Exactly as `transfer`, except the origin must be root and the source account may be",
                " specified.",
                " # <weight>",
                " - Same as transfer, but additional read and write because the source account is",
                "   not assumed to be in the overlay.",
                " # </weight>"
              ]
            },
            {
              "name": "transfer_keep_alive",
              "args": [
                {
                  "name": "dest",
                  "type": "LookupSource"
                },
                {
                  "name": "value",
                  "type": "Compact<Balance>"
                }
              ],
              "docs": [
                " Same as the [`transfer`] call, but with a check that the transfer will not kill the",
                " origin account.",
                "",
                " 99% of the time you want [`transfer`] instead.",
                "",
                " [`transfer`]: struct.Pallet.html#method.transfer",
                " # <weight>",
                " - Cheaper than transfer because account cannot be killed.",
                " - Base Weight: 51.4 Âµs",
                " - DB Weight: 1 Read and 1 Write to dest (sender is in overlay already)",
                " #</weight>"
              ]
            },
            {
              "name": "transfer_all",
              "args": [
                {
                  "name": "dest",
                  "type": "LookupSource"
                },
                {
                  "name": "keep_alive",
                  "type": "bool"
                }
              ],
              "docs": [
                " Transfer the entire transferable balance from the caller account.",
                "",
                " NOTE: This function only attempts to transfer _transferable_ balances. This means that",
                " any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be",
                " transferred by this function. To ensure that this function results in a killed account,",
                " you might need to prepare the account by removing any reference counters, storage",
                " deposits, etc...",
                "",
                " The dispatch origin of this call must be Signed.",
                "",
                " - `dest`: The recipient of the transfer.",
                " - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all",
                "   of the funds the account has, causing the sender account to be killed (false), or",
                "   transfer everything except at least the existential deposit, which will guarantee to",
                "   keep the sender account alive (true).",
                "   # <weight>",
                " - O(1). Just like transfer, but reading the user's transferable balance first.",
                "   #</weight>"
              ]
            }
          ],
          "events": [
            {
              "name": "Endowed",
              "args": [
                "AccountId",
                "Balance"
              ],
              "docs": [
                " An account was created with some free balance. \\[account, free_balance\\]"
              ]
            },
            {
              "name": "DustLost",
              "args": [
                "AccountId",
                "Balance"
              ],
              "docs": [
                " An account was removed whose balance was non-zero but below ExistentialDeposit,",
                " resulting in an outright loss. \\[account, balance\\]"
              ]
            },
            {
              "name": "Transfer",
              "args": [
                "AccountId",
                "AccountId",
                "Balance"
              ],
              "docs": [
                " Transfer succeeded. \\[from, to, value\\]"
              ]
            },
            {
              "name": "BalanceSet",
              "args": [
                "AccountId",
                "Balance",
                "Balance"
              ],
              "docs": [
                " A balance was set by root. \\[who, free, reserved\\]"
              ]
            },
            {
              "name": "Deposit",
              "args": [
                "AccountId",
                "Balance"
              ],
              "docs": [
                " Some amount was deposited (e.g. for transaction fees). \\[who, deposit\\]"
              ]
            },
            {
              "name": "Reserved",
              "args": [
                "AccountId",
                "Balance"
              ],
              "docs": [
                " Some balance was reserved (moved from free to reserved). \\[who, value\\]"
              ]
            },
            {
              "name": "Unreserved",
              "args": [
                "AccountId",
                "Balance"
              ],
              "docs": [
                " Some balance was unreserved (moved from reserved to free). \\[who, value\\]"
              ]
            },
            {
              "name": "ReserveRepatriated",
              "args": [
                "AccountId",
                "AccountId",
                "Balance",
                "BalanceStatus"
              ],
              "docs": [
                " Some balance was moved from the reserve of the first account to the second account.",
                " Final argument indicates the destination balance type.",
                " \\[from, to, balance, destination_status\\]"
              ]
            }
          ],
          "constants": [
            {
              "name": "ExistentialDeposit",
              "type": "Balance",
              "value": "0xf4010000000000000000000000000000",
              "docs": [
                " The minimum amount required to keep an account open."
              ]
            },
            {
              "name": "MaxLocks",
              "type": "u32",
              "value": "0x32000000",
              "docs": [
                " The maximum number of locks that should exist on an account.",
                " Not strictly enforced, but used for weight estimation."
              ]
            },
            {
              "name": "MaxReserves",
              "type": "u32",
              "value": "0x00000000",
              "docs": [
                " The maximum number of named reserves that can exist on an account."
              ]
            }
          ],
          "errors": [
            {
              "name": "VestingBalance",
              "docs": [
                " Vesting balance too high to send value"
              ]
            },
            {
              "name": "LiquidityRestrictions",
              "docs": [
                " Account liquidity restrictions prevent withdrawal"
              ]
            },
            {
              "name": "InsufficientBalance",
              "docs": [
                " Balance too low to send value"
              ]
            },
            {
              "name": "ExistentialDeposit",
              "docs": [
                " Value too low to create account due to existential deposit"
              ]
            },
            {
              "name": "KeepAlive",
              "docs": [
                " Transfer/payment would kill account"
              ]
            },
            {
              "name": "ExistingVestingSchedule",
              "docs": [
                " A vesting schedule already exists for this account"
              ]
            },
            {
              "name": "DeadAccount",
              "docs": [
                " Beneficiary account must pre-exist"
              ]
            },
            {
              "name": "TooManyReserves",
              "docs": [
                " Number of named reserves exceed MaxReserves"
              ]
            }
          ],
          "index": 5
        },
        {
          "name": "Vesting",
          "storage": {
            "prefix": "Vesting",
            "items": [
              {
                "name": "Vesting",
                "modifier": "Optional",
                "type": {
                  "map": {
                    "hasher": "Blake2_128Concat",
                    "key": "AccountId",
                    "value": "VestingInfo",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Information regarding the vesting of a given account."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "vest",
              "args": [],
              "docs": [
                " Unlock any vested funds of the sender account.",
                "",
                " The dispatch origin for this call must be _Signed_ and the sender must have funds still",
                " locked under this pallet.",
                "",
                " Emits either `VestingCompleted` or `VestingUpdated`.",
                "",
                " # <weight>",
                " - `O(1)`.",
                " - DbWeight: 2 Reads, 2 Writes",
                "     - Reads: Vesting Storage, Balances Locks, [Sender Account]",
                "     - Writes: Vesting Storage, Balances Locks, [Sender Account]",
                " # </weight>"
              ]
            },
            {
              "name": "vest_other",
              "args": [
                {
                  "name": "target",
                  "type": "LookupSource"
                }
              ],
              "docs": [
                " Unlock any vested funds of a `target` account.",
                "",
                " The dispatch origin for this call must be _Signed_.",
                "",
                " - `target`: The account whose vested funds should be unlocked. Must have funds still",
                " locked under this pallet.",
                "",
                " Emits either `VestingCompleted` or `VestingUpdated`.",
                "",
                " # <weight>",
                " - `O(1)`.",
                " - DbWeight: 3 Reads, 3 Writes",
                "     - Reads: Vesting Storage, Balances Locks, Target Account",
                "     - Writes: Vesting Storage, Balances Locks, Target Account",
                " # </weight>"
              ]
            },
            {
              "name": "vested_transfer",
              "args": [
                {
                  "name": "target",
                  "type": "LookupSource"
                },
                {
                  "name": "schedule",
                  "type": "VestingInfo"
                }
              ],
              "docs": [
                " Create a vested transfer.",
                "",
                " The dispatch origin for this call must be _Signed_.",
                "",
                " - `target`: The account that should be transferred the vested funds.",
                " - `amount`: The amount of funds to transfer and will be vested.",
                " - `schedule`: The vesting schedule attached to the transfer.",
                "",
                " Emits `VestingCreated`.",
                "",
                " # <weight>",
                " - `O(1)`.",
                " - DbWeight: 3 Reads, 3 Writes",
                "     - Reads: Vesting Storage, Balances Locks, Target Account, [Sender Account]",
                "     - Writes: Vesting Storage, Balances Locks, Target Account, [Sender Account]",
                " # </weight>"
              ]
            },
            {
              "name": "force_vested_transfer",
              "args": [
                {
                  "name": "source",
                  "type": "LookupSource"
                },
                {
                  "name": "target",
                  "type": "LookupSource"
                },
                {
                  "name": "schedule",
                  "type": "VestingInfo"
                }
              ],
              "docs": [
                " Force a vested transfer.",
                "",
                " The dispatch origin for this call must be _Root_.",
                "",
                " - `source`: The account whose funds should be transferred.",
                " - `target`: The account that should be transferred the vested funds.",
                " - `amount`: The amount of funds to transfer and will be vested.",
                " - `schedule`: The vesting schedule attached to the transfer.",
                "",
                " Emits `VestingCreated`.",
                "",
                " # <weight>",
                " - `O(1)`.",
                " - DbWeight: 4 Reads, 4 Writes",
                "     - Reads: Vesting Storage, Balances Locks, Target Account, Source Account",
                "     - Writes: Vesting Storage, Balances Locks, Target Account, Source Account",
                " # </weight>"
              ]
            }
          ],
          "events": [
            {
              "name": "VestingUpdated",
              "args": [
                "AccountId",
                "Balance"
              ],
              "docs": [
                " The amount vested has been updated. This could indicate more funds are available. The",
                " balance given is the amount which is left unvested (and thus locked).",
                " \\[account, unvested\\]"
              ]
            },
            {
              "name": "VestingCompleted",
              "args": [
                "AccountId"
              ],
              "docs": [
                " An \\[account\\] has become fully vested. No further vesting can happen."
              ]
            }
          ],
          "constants": [
            {
              "name": "MinVestedTransfer",
              "type": "BalanceOf",
              "value": "0x000064a7b3b6e00d0000000000000000",
              "docs": [
                " The minimum amount transferred to call `vested_transfer`."
              ]
            }
          ],
          "errors": [
            {
              "name": "NotVesting",
              "docs": [
                " The account given is not vesting."
              ]
            },
            {
              "name": "ExistingVestingSchedule",
              "docs": [
                " An existing vesting schedule already exists for this account that cannot be clobbered."
              ]
            },
            {
              "name": "AmountLow",
              "docs": [
                " Amount being transferred is too low to create a vesting schedule."
              ]
            }
          ],
          "index": 6
        },
        {
          "name": "DappsStaking",
          "storage": {
            "prefix": "DappsStaking",
            "items": [
              {
                "name": "Ledger",
                "modifier": "Optional",
                "type": {
                  "map": {
                    "hasher": "Twox64Concat",
                    "key": "AccountId",
                    "value": "BalanceOf",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Bonded amount for the staker"
                ]
              },
              {
                "name": "HistoryDepth",
                "modifier": "Default",
                "type": {
                  "plain": "u32"
                },
                "fallback": "0x1e000000",
                "docs": [
                  " Number of eras to keep in history.",
                  "",
                  " Information is kept for eras in `[current_era - history_depth; current_era]`."
                ]
              },
              {
                "name": "CurrentEra",
                "modifier": "Default",
                "type": {
                  "plain": "EraIndex"
                },
                "fallback": "0x00000000",
                "docs": [
                  " The current era index."
                ]
              },
              {
                "name": "BlockRewardAccumulator",
                "modifier": "Default",
                "type": {
                  "plain": "BalanceOf"
                },
                "fallback": "0x00000000000000000000000000000000",
                "docs": [
                  " Accumulator for block rewards during an era. It is reset at every new era"
                ]
              },
              {
                "name": "ForceEra",
                "modifier": "Default",
                "type": {
                  "plain": "Forcing"
                },
                "fallback": "0x02",
                "docs": [
                  " Mode of era forcing."
                ]
              },
              {
                "name": "RegisteredDevelopers",
                "modifier": "Optional",
                "type": {
                  "map": {
                    "hasher": "Twox64Concat",
                    "key": "AccountId",
                    "value": "SmartContract",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Registered developer accounts points to coresponding contract"
                ]
              },
              {
                "name": "RegisteredDapps",
                "modifier": "Optional",
                "type": {
                  "map": {
                    "hasher": "Twox64Concat",
                    "key": "SmartContract",
                    "value": "AccountId",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Registered dapp points to the developer who registered it"
                ]
              },
              {
                "name": "EraRewardsAndStakes",
                "modifier": "Optional",
                "type": {
                  "map": {
                    "hasher": "Twox64Concat",
                    "key": "EraIndex",
                    "value": "EraRewardAndStake",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Total block rewards for the pallet per era and total staked funds"
                ]
              },
              {
                "name": "RewardsClaimed",
                "modifier": "Default",
                "type": {
                  "doubleMap": {
                    "hasher": "Twox64Concat",
                    "key1": "SmartContract",
                    "key2": "AccountId",
                    "value": "BalanceOf",
                    "key2Hasher": "Twox64Concat"
                  }
                },
                "fallback": "0x00000000000000000000000000000000",
                "docs": [
                  " Reward counter for individual stakers and the developer"
                ]
              },
              {
                "name": "ContractEraStake",
                "modifier": "Optional",
                "type": {
                  "doubleMap": {
                    "hasher": "Twox64Concat",
                    "key1": "SmartContract",
                    "key2": "EraIndex",
                    "value": "EraStakingPoints",
                    "key2Hasher": "Twox64Concat"
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Stores amount staked and stakers for a contract per era"
                ]
              },
              {
                "name": "ContractLastClaimed",
                "modifier": "Optional",
                "type": {
                  "map": {
                    "hasher": "Twox64Concat",
                    "key": "SmartContract",
                    "value": "EraIndex",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Marks an Era when a contract is last claimed"
                ]
              },
              {
                "name": "ContractLastStaked",
                "modifier": "Optional",
                "type": {
                  "map": {
                    "hasher": "Twox64Concat",
                    "key": "SmartContract",
                    "value": "EraIndex",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Marks an Era when a contract is last (un)staked"
                ]
              },
              {
                "name": "PreApprovalIsEnabled",
                "modifier": "Default",
                "type": {
                  "plain": "bool"
                },
                "fallback": "0x00",
                "docs": [
                  " Enable or disable pre-approval list for new contract registration"
                ]
              },
              {
                "name": "PreApprovedDevelopers",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Twox64Concat",
                    "key": "AccountId",
                    "value": "()",
                    "linked": false
                  }
                },
                "fallback": "0x",
                "docs": [
                  " List of pre-approved developers"
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "register",
              "args": [
                {
                  "name": "contract_id",
                  "type": "SmartContract"
                }
              ],
              "docs": [
                " register contract into staking targets.",
                " contract_id should be ink! or evm contract.",
                "",
                " Any user can call this function.",
                " However, caller have to have deposit amount.",
                " TODO: weight, and add registrationFee"
              ]
            },
            {
              "name": "developer_pre_approval",
              "args": [
                {
                  "name": "developer",
                  "type": "AccountId"
                }
              ],
              "docs": [
                " add contract address to the pre-approved list.",
                " contract_id should be ink! or evm contract.",
                "",
                " Sudo call is required"
              ]
            },
            {
              "name": "enable_developer_pre_approval",
              "args": [
                {
                  "name": "enabled",
                  "type": "bool"
                }
              ],
              "docs": [
                " Enable or disable adding new contracts to the pre-approved list",
                "",
                " Sudo call is required"
              ]
            },
            {
              "name": "bond_and_stake",
              "args": [
                {
                  "name": "contract_id",
                  "type": "SmartContract"
                },
                {
                  "name": "value",
                  "type": "Compact<BalanceOf>"
                }
              ],
              "docs": [
                " Lock up and stake balance of the origin account.",
                "",
                " `value` must be more than the `minimum_balance` specified by `T::Currency`",
                " unless account already has bonded value equal or more than 'minimum_balance'.",
                "",
                " The dispatch origin for this call must be _Signed_ by the staker's account.",
                "",
                " Effects of staking will be felt at the beginning of the next era.",
                "",
                " TODO: Weight!"
              ]
            },
            {
              "name": "unbond_unstake_and_withdraw",
              "args": [
                {
                  "name": "contract_id",
                  "type": "SmartContract"
                },
                {
                  "name": "value",
                  "type": "Compact<BalanceOf>"
                }
              ],
              "docs": [
                " Unbond, unstake and withdraw balance from the contract.",
                "",
                " Value will be unlocked for the user.",
                "",
                " In case remaining staked balance on contract is below minimum staking amount,",
                " entire stake for that contract will be unstaked.",
                "",
                " # <weight>",
                " TODO!",
                " </weight>"
              ]
            },
            {
              "name": "claim",
              "args": [
                {
                  "name": "contract_id",
                  "type": "SmartContract"
                }
              ],
              "docs": [
                " claim the rewards earned by contract_id.",
                " All stakers and developer for this contract will be paid out with single call.",
                " claim is valid for all unclaimed eras but not longer than history_depth().",
                " Any reward older than history_depth() will go to Treasury.",
                " Any user can call this function."
              ]
            },
            {
              "name": "force_new_era",
              "args": [],
              "docs": [
                " Force there to be a new era at the end of the next block. After this, it will be",
                " reset to normal (non-forced) behaviour.",
                "",
                " The dispatch origin must be Root.",
                "",
                "",
                " # <weight>",
                " - No arguments.",
                " - Weight: O(1)",
                " - Write ForceEra",
                " # </weight>"
              ]
            }
          ],
          "events": [
            {
              "name": "BondAndStake",
              "args": [
                "AccountId",
                "SmartContract",
                "Balance"
              ],
              "docs": [
                " Account has bonded and staked funds on a smart contract."
              ]
            },
            {
              "name": "UnbondUnstakeAndWithdraw",
              "args": [
                "AccountId",
                "SmartContract",
                "Balance"
              ],
              "docs": [
                " Account has unbonded, unstaked and withdrawn funds."
              ]
            },
            {
              "name": "NewContract",
              "args": [
                "AccountId",
                "SmartContract"
              ],
              "docs": [
                " New contract added for staking."
              ]
            },
            {
              "name": "NewDappStakingEra",
              "args": [
                "EraIndex"
              ],
              "docs": [
                " New dapps staking era. Distribute era rewards to contracts."
              ]
            },
            {
              "name": "ContractClaimed",
              "args": [
                "SmartContract",
                "AccountId",
                "EraIndex",
                "EraIndex"
              ],
              "docs": [
                " The contract's reward have been claimed, by an account, from era, until era."
              ]
            }
          ],
          "constants": [
            {
              "name": "BlockPerEra",
              "type": "BlockNumberFor",
              "value": "0x3c000000",
              "docs": [
                " Number of blocks per era."
              ]
            },
            {
              "name": "RegisterDeposit",
              "type": "BalanceOf",
              "value": "0x000010632d5ec76b0500000000000000",
              "docs": [
                " Minimum bonded deposit for new contract registration."
              ]
            },
            {
              "name": "DeveloperRewardPercentage",
              "type": "u32",
              "value": "0x50000000",
              "docs": [
                " Percentage of reward paid to developer."
              ]
            },
            {
              "name": "MaxNumberOfStakersPerContract",
              "type": "u32",
              "value": "0x80000000",
              "docs": [
                " Maximum number of unique stakers per contract."
              ]
            },
            {
              "name": "MinimumStakingAmount",
              "type": "BalanceOf",
              "value": "0x0a000000000000000000000000000000",
              "docs": [
                " Minimum amount user must stake on contract.",
                " User can stake less if they already have the minimum staking amount staked on that particular contract."
              ]
            },
            {
              "name": "PalletId",
              "type": "PalletId",
              "value": "0x70792f6470737374",
              "docs": [
                " Dapps staking pallet Id"
              ]
            }
          ],
          "errors": [
            {
              "name": "StakingWithNoValue",
              "docs": [
                " Can not stake with zero value."
              ]
            },
            {
              "name": "InsufficientStakingValue",
              "docs": [
                " Can not stake with value less than minimum staking value"
              ]
            },
            {
              "name": "MaxNumberOfStakersExceeded",
              "docs": [
                " Number of stakers per contract exceeded."
              ]
            },
            {
              "name": "NotOperatedContract",
              "docs": [
                " Targets must be operated contracts"
              ]
            },
            {
              "name": "NotStakedContract",
              "docs": [
                " Contract isn't staked."
              ]
            },
            {
              "name": "UnstakingWithNoValue",
              "docs": [
                " Unstaking a contract with zero value"
              ]
            },
            {
              "name": "AlreadyRegisteredContract",
              "docs": [
                " The contract is already registered by other account"
              ]
            },
            {
              "name": "ContractIsNotValid",
              "docs": [
                " User attempts to register with address which is not contract"
              ]
            },
            {
              "name": "ContractNotRegistered",
              "docs": [
                " Claiming contract with no developer account"
              ]
            },
            {
              "name": "AlreadyUsedDeveloperAccount",
              "docs": [
                " This account was already used to register contract"
              ]
            },
            {
              "name": "UnexpectedState",
              "docs": [
                " Unexpected state error, used to abort transaction. Used for situations that 'should never happen'."
              ]
            },
            {
              "name": "UnknownStartStakingData",
              "docs": [
                " Report issue on github if this is ever emitted"
              ]
            },
            {
              "name": "UnknownEraReward",
              "docs": [
                " Report issue on github if this is ever emitted"
              ]
            },
            {
              "name": "NothingToClaim",
              "docs": [
                " There are no funds to reward the contract. Or already claimed in that era"
              ]
            },
            {
              "name": "AlreadyClaimedInThisEra",
              "docs": [
                " Contract already claimed in this era and reward is distributed"
              ]
            },
            {
              "name": "RequiredContractPreApproval",
              "docs": [
                " To register a contract, pre-approval is needed for this address"
              ]
            },
            {
              "name": "AlreadyPreApprovedDeveloper",
              "docs": [
                " Developer's account is already part of pre-approved list"
              ]
            }
          ],
          "index": 7
        },
        {
          "name": "BlockReward",
          "storage": null,
          "calls": null,
          "events": null,
          "constants": [
            {
              "name": "RewardAmount",
              "type": "BalanceOf",
              "value": "0x0000a4b1e26df8240000000000000000",
              "docs": [
                " The amount of issuance for each block."
              ]
            },
            {
              "name": "DAppsRewardPercentage",
              "type": "u32",
              "value": "0x32000000",
              "docs": [
                " The percentage of issueance that goes to pallet-dapps-staking"
              ]
            }
          ],
          "errors": [],
          "index": 8
        },
        {
          "name": "TransactionPayment",
          "storage": {
            "prefix": "TransactionPayment",
            "items": [
              {
                "name": "NextFeeMultiplier",
                "modifier": "Default",
                "type": {
                  "plain": "Multiplier"
                },
                "fallback": "0x000064a7b3b6e00d0000000000000000",
                "docs": []
              },
              {
                "name": "StorageVersion",
                "modifier": "Default",
                "type": {
                  "plain": "Releases"
                },
                "fallback": "0x00",
                "docs": []
              }
            ]
          },
          "calls": null,
          "events": null,
          "constants": [
            {
              "name": "TransactionByteFee",
              "type": "BalanceOf",
              "value": "0x01000000000000000000000000000000",
              "docs": [
                " The fee to be paid for making a transaction; the per-byte portion."
              ]
            },
            {
              "name": "WeightToFee",
              "type": "Vec<WeightToFeeCoefficient>",
              "value": "0x0401000000000000000000000000000000000000000001",
              "docs": [
                " The polynomial that is applied in order to derive fee from weight."
              ]
            }
          ],
          "errors": [],
          "index": 9
        },
        {
          "name": "EVM",
          "storage": {
            "prefix": "EVM",
            "items": [
              {
                "name": "AccountCodes",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Blake2_128Concat",
                    "key": "H160",
                    "value": "Bytes",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": []
              },
              {
                "name": "AccountStorages",
                "modifier": "Default",
                "type": {
                  "doubleMap": {
                    "hasher": "Blake2_128Concat",
                    "key1": "H160",
                    "key2": "H256",
                    "value": "H256",
                    "key2Hasher": "Blake2_128Concat"
                  }
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "docs": []
              }
            ]
          },
          "calls": [
            {
              "name": "withdraw",
              "args": [
                {
                  "name": "address",
                  "type": "H160"
                },
                {
                  "name": "value",
                  "type": "BalanceOf"
                }
              ],
              "docs": [
                " Withdraw balance from EVM into currency/balances pallet."
              ]
            },
            {
              "name": "call",
              "args": [
                {
                  "name": "source",
                  "type": "H160"
                },
                {
                  "name": "target",
                  "type": "H160"
                },
                {
                  "name": "input",
                  "type": "Bytes"
                },
                {
                  "name": "value",
                  "type": "U256"
                },
                {
                  "name": "gas_limit",
                  "type": "u64"
                },
                {
                  "name": "gas_price",
                  "type": "U256"
                },
                {
                  "name": "nonce",
                  "type": "Option<U256>"
                }
              ],
              "docs": [
                " Issue an EVM call operation. This is similar to a message call transaction in Ethereum."
              ]
            },
            {
              "name": "create",
              "args": [
                {
                  "name": "source",
                  "type": "H160"
                },
                {
                  "name": "init",
                  "type": "Bytes"
                },
                {
                  "name": "value",
                  "type": "U256"
                },
                {
                  "name": "gas_limit",
                  "type": "u64"
                },
                {
                  "name": "gas_price",
                  "type": "U256"
                },
                {
                  "name": "nonce",
                  "type": "Option<U256>"
                }
              ],
              "docs": [
                " Issue an EVM create operation. This is similar to a contract creation transaction in",
                " Ethereum."
              ]
            },
            {
              "name": "create2",
              "args": [
                {
                  "name": "source",
                  "type": "H160"
                },
                {
                  "name": "init",
                  "type": "Bytes"
                },
                {
                  "name": "salt",
                  "type": "H256"
                },
                {
                  "name": "value",
                  "type": "U256"
                },
                {
                  "name": "gas_limit",
                  "type": "u64"
                },
                {
                  "name": "gas_price",
                  "type": "U256"
                },
                {
                  "name": "nonce",
                  "type": "Option<U256>"
                }
              ],
              "docs": [
                " Issue an EVM create2 operation."
              ]
            }
          ],
          "events": [
            {
              "name": "Log",
              "args": [
                "EvmLog"
              ],
              "docs": [
                " Ethereum events from contracts."
              ]
            },
            {
              "name": "Created",
              "args": [
                "H160"
              ],
              "docs": [
                " A contract has been created at given \\[address\\]."
              ]
            },
            {
              "name": "CreatedFailed",
              "args": [
                "H160"
              ],
              "docs": [
                " A \\[contract\\] was attempted to be created, but the execution failed."
              ]
            },
            {
              "name": "Executed",
              "args": [
                "H160"
              ],
              "docs": [
                " A \\[contract\\] has been executed successfully with states applied."
              ]
            },
            {
              "name": "ExecutedFailed",
              "args": [
                "H160"
              ],
              "docs": [
                " A \\[contract\\] has been executed with errors. States are reverted with only gas fees applied."
              ]
            },
            {
              "name": "BalanceDeposit",
              "args": [
                "AccountId",
                "H160",
                "U256"
              ],
              "docs": [
                " A deposit has been made at a given address. \\[sender, address, value\\]"
              ]
            },
            {
              "name": "BalanceWithdraw",
              "args": [
                "AccountId",
                "H160",
                "U256"
              ],
              "docs": [
                " A withdrawal has been made from a given address. \\[sender, address, value\\]"
              ]
            }
          ],
          "constants": [],
          "errors": [
            {
              "name": "BalanceLow",
              "docs": [
                " Not enough balance to perform action"
              ]
            },
            {
              "name": "FeeOverflow",
              "docs": [
                " Calculating total fee overflowed"
              ]
            },
            {
              "name": "PaymentOverflow",
              "docs": [
                " Calculating total payment overflowed"
              ]
            },
            {
              "name": "WithdrawFailed",
              "docs": [
                " Withdraw fee failed"
              ]
            },
            {
              "name": "GasPriceTooLow",
              "docs": [
                " Gas price is too low."
              ]
            },
            {
              "name": "InvalidNonce",
              "docs": [
                " Nonce is invalid"
              ]
            }
          ],
          "index": 10
        },
        {
          "name": "Ethereum",
          "storage": {
            "prefix": "Ethereum",
            "items": [
              {
                "name": "Pending",
                "modifier": "Default",
                "type": {
                  "plain": "Vec<(EthTransaction,EthTransactionStatus,EthReceipt)>"
                },
                "fallback": "0x00",
                "docs": [
                  " Current building block's transactions and receipts."
                ]
              },
              {
                "name": "CurrentBlock",
                "modifier": "Optional",
                "type": {
                  "plain": "BlockV0"
                },
                "fallback": "0x00",
                "docs": [
                  " The current Ethereum block."
                ]
              },
              {
                "name": "CurrentReceipts",
                "modifier": "Optional",
                "type": {
                  "plain": "Vec<EthReceipt>"
                },
                "fallback": "0x00",
                "docs": [
                  " The current Ethereum receipts."
                ]
              },
              {
                "name": "CurrentTransactionStatuses",
                "modifier": "Optional",
                "type": {
                  "plain": "Vec<EthTransactionStatus>"
                },
                "fallback": "0x00",
                "docs": [
                  " The current transaction statuses."
                ]
              },
              {
                "name": "BlockHash",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Twox64Concat",
                    "key": "U256",
                    "value": "H256",
                    "linked": false
                  }
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "docs": []
              }
            ]
          },
          "calls": [
            {
              "name": "transact",
              "args": [
                {
                  "name": "transaction",
                  "type": "EthTransaction"
                }
              ],
              "docs": [
                " Transact an Ethereum transaction."
              ]
            }
          ],
          "events": [
            {
              "name": "Executed",
              "args": [
                "H160",
                "H160",
                "H256",
                "ExitReason"
              ],
              "docs": [
                " An ethereum transaction was successfully executed. [from, to/contract_address, transaction_hash, exit_reason]"
              ]
            }
          ],
          "constants": [],
          "errors": [
            {
              "name": "InvalidSignature",
              "docs": [
                " Signature is invalid."
              ]
            },
            {
              "name": "PreLogExists",
              "docs": [
                " Pre-log is present, therefore transact is not allowed."
              ]
            }
          ],
          "index": 11
        },
        {
          "name": "EthCall",
          "storage": null,
          "calls": [
            {
              "name": "call",
              "args": [
                {
                  "name": "call",
                  "type": "Call"
                },
                {
                  "name": "signer",
                  "type": "AccountId"
                },
                {
                  "name": "signature",
                  "type": "Bytes"
                },
                {
                  "name": "nonce",
                  "type": "Compact<Index>"
                }
              ],
              "docs": [
                " # <weight>",
                " - O(1).",
                " - Limited storage reads.",
                " - One DB write (event).",
                " - Weight of derivative `call` execution + 10,000.",
                " # </weight>"
              ]
            }
          ],
          "events": [
            {
              "name": "Executed",
              "args": [
                "AccountId",
                "DispatchResult"
              ],
              "docs": [
                " A call just executed. \\[result\\]"
              ]
            }
          ],
          "constants": [
            {
              "name": "CallFee",
              "type": "BalanceOf",
              "value": "0x00008a5d784563010000000000000000",
              "docs": [
                " The call processing fee amount."
              ]
            },
            {
              "name": "CallMagicNumber",
              "type": "u16",
              "value": "0x51ff",
              "docs": [
                " The call magic number."
              ]
            }
          ],
          "errors": [
            {
              "name": "DecodeFailure",
              "docs": [
                " Signature decode fails."
              ]
            },
            {
              "name": "InvalidSignature",
              "docs": [
                " Signature and account mismatched."
              ]
            },
            {
              "name": "BadNonce",
              "docs": [
                " Bad nonce parameter."
              ]
            }
          ],
          "index": 12
        },
        {
          "name": "Contracts",
          "storage": {
            "prefix": "Contracts",
            "items": [
              {
                "name": "PristineCode",
                "modifier": "Optional",
                "type": {
                  "map": {
                    "hasher": "Identity",
                    "key": "CodeHash",
                    "value": "Bytes",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " A mapping from an original code hash to the original code, untouched by instrumentation."
                ]
              },
              {
                "name": "CodeStorage",
                "modifier": "Optional",
                "type": {
                  "map": {
                    "hasher": "Identity",
                    "key": "CodeHash",
                    "value": "PrefabWasmModule",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " A mapping between an original code hash and instrumented wasm code, ready for execution."
                ]
              },
              {
                "name": "AccountCounter",
                "modifier": "Default",
                "type": {
                  "plain": "u64"
                },
                "fallback": "0x0000000000000000",
                "docs": [
                  " The subtrie counter."
                ]
              },
              {
                "name": "ContractInfoOf",
                "modifier": "Optional",
                "type": {
                  "map": {
                    "hasher": "Twox64Concat",
                    "key": "AccountId",
                    "value": "ContractInfo",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " The code associated with a given account.",
                  "",
                  " TWOX-NOTE: SAFE since `AccountId` is a secure hash."
                ]
              },
              {
                "name": "DeletionQueue",
                "modifier": "Default",
                "type": {
                  "plain": "Vec<DeletedContract>"
                },
                "fallback": "0x00",
                "docs": [
                  " Evicted contracts that await child trie deletion.",
                  "",
                  " Child trie deletion is a heavy operation depending on the amount of storage items",
                  " stored in said trie. Therefore this operation is performed lazily in `on_initialize`."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "call",
              "args": [
                {
                  "name": "dest",
                  "type": "LookupSource"
                },
                {
                  "name": "value",
                  "type": "Compact<BalanceOf>"
                },
                {
                  "name": "gas_limit",
                  "type": "Compact<Weight>"
                },
                {
                  "name": "data",
                  "type": "Bytes"
                }
              ],
              "docs": [
                " Makes a call to an account, optionally transferring some balance.",
                "",
                " * If the account is a smart-contract account, the associated code will be",
                " executed and any value will be transferred.",
                " * If the account is a regular account, any value will be transferred.",
                " * If no account exists and the call value is not less than `existential_deposit`,",
                " a regular account will be created and any value will be transferred."
              ]
            },
            {
              "name": "instantiate_with_code",
              "args": [
                {
                  "name": "endowment",
                  "type": "Compact<BalanceOf>"
                },
                {
                  "name": "gas_limit",
                  "type": "Compact<Weight>"
                },
                {
                  "name": "code",
                  "type": "Bytes"
                },
                {
                  "name": "data",
                  "type": "Bytes"
                },
                {
                  "name": "salt",
                  "type": "Bytes"
                }
              ],
              "docs": [
                " Instantiates a new contract from the supplied `code` optionally transferring",
                " some balance.",
                "",
                " This is the only function that can deploy new code to the chain.",
                "",
                " # Parameters",
                "",
                " * `endowment`: The balance to transfer from the `origin` to the newly created contract.",
                " * `gas_limit`: The gas limit enforced when executing the constructor.",
                " * `code`: The contract code to deploy in raw bytes.",
                " * `data`: The input data to pass to the contract constructor.",
                " * `salt`: Used for the address derivation. See [`Pallet::contract_address`].",
                "",
                " Instantiation is executed as follows:",
                "",
                " - The supplied `code` is instrumented, deployed, and a `code_hash` is created for that code.",
                " - If the `code_hash` already exists on the chain the underlying `code` will be shared.",
                " - The destination address is computed based on the sender, code_hash and the salt.",
                " - The smart-contract account is created at the computed address.",
                " - The `endowment` is transferred to the new account.",
                " - The `deploy` function is executed in the context of the newly-created account."
              ]
            },
            {
              "name": "instantiate",
              "args": [
                {
                  "name": "endowment",
                  "type": "Compact<BalanceOf>"
                },
                {
                  "name": "gas_limit",
                  "type": "Compact<Weight>"
                },
                {
                  "name": "code_hash",
                  "type": "CodeHash"
                },
                {
                  "name": "data",
                  "type": "Bytes"
                },
                {
                  "name": "salt",
                  "type": "Bytes"
                }
              ],
              "docs": [
                " Instantiates a contract from a previously deployed wasm binary.",
                "",
                " This function is identical to [`Self::instantiate_with_code`] but without the",
                " code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary",
                " must be supplied."
              ]
            },
            {
              "name": "claim_surcharge",
              "args": [
                {
                  "name": "dest",
                  "type": "AccountId"
                },
                {
                  "name": "aux_sender",
                  "type": "Option<AccountId>"
                }
              ],
              "docs": [
                " Allows block producers to claim a small reward for evicting a contract. If a block",
                " producer fails to do so, a regular users will be allowed to claim the reward.",
                "",
                " In case of a successful eviction no fees are charged from the sender. However, the",
                " reward is capped by the total amount of rent that was paid by the contract while",
                " it was alive.",
                "",
                " If contract is not evicted as a result of this call, [`Error::ContractNotEvictable`]",
                " is returned and the sender is not eligible for the reward."
              ]
            }
          ],
          "events": [
            {
              "name": "Instantiated",
              "args": [
                "AccountId",
                "AccountId"
              ],
              "docs": [
                " Contract deployed by address at the specified address. \\[deployer, contract\\]"
              ]
            },
            {
              "name": "Evicted",
              "args": [
                "AccountId"
              ],
              "docs": [
                " Contract has been evicted and is now in tombstone state. \\[contract\\]"
              ]
            },
            {
              "name": "Terminated",
              "args": [
                "AccountId",
                "AccountId"
              ],
              "docs": [
                " Contract has been terminated without leaving a tombstone.",
                " \\[contract, beneficiary\\]",
                "",
                " # Params",
                "",
                " - `contract`: The contract that was terminated.",
                " - `beneficiary`: The account that received the contracts remaining balance.",
                "",
                " # Note",
                "",
                " The only way for a contract to be removed without a tombstone and emitting",
                " this event is by calling `seal_terminate`."
              ]
            },
            {
              "name": "Restored",
              "args": [
                "AccountId",
                "AccountId",
                "Hash",
                "Balance"
              ],
              "docs": [
                " Restoration of a contract has been successful.",
                " \\[restorer, dest, code_hash, rent_allowance\\]",
                "",
                " # Params",
                "",
                " - `restorer`: Account ID of the restoring contract.",
                " - `dest`: Account ID of the restored contract.",
                " - `code_hash`: Code hash of the restored contract.",
                " - `rent_allowance`: Rent allowance of the restored contract."
              ]
            },
            {
              "name": "CodeStored",
              "args": [
                "Hash"
              ],
              "docs": [
                " Code with the specified hash has been stored. \\[code_hash\\]"
              ]
            },
            {
              "name": "ScheduleUpdated",
              "args": [
                "u32"
              ],
              "docs": [
                " Triggered when the current schedule is updated.",
                " \\[version\\]",
                "",
                " # Params",
                "",
                " - `version`: The version of the newly set schedule."
              ]
            },
            {
              "name": "ContractEmitted",
              "args": [
                "AccountId",
                "Bytes"
              ],
              "docs": [
                " A custom event emitted by the contract.",
                " \\[contract, data\\]",
                "",
                " # Params",
                "",
                " - `contract`: The contract that emitted the event.",
                " - `data`: Data supplied by the contract. Metadata generated during contract",
                "           compilation is needed to decode it."
              ]
            },
            {
              "name": "CodeRemoved",
              "args": [
                "Hash"
              ],
              "docs": [
                " A code with the specified hash was removed.",
                " \\[code_hash\\]",
                "",
                " This happens when the last contract that uses this code hash was removed or evicted."
              ]
            }
          ],
          "constants": [
            {
              "name": "Schedule",
              "type": "Schedule",
              "value": "0x040000000002000000010000800000001000000000100000000100002000000020000000004000000000020002000000810600004e6202009680030050150000ee180000c2090000cf140000b52600009a000000cc5101005dc002004d090000a206000059080000d80600002b1c0000d41e0000ec0900005ca8b5082d08000043070000e40a00000a0700008d0600000d0600009a0600001f08000010080000be0700008f080000040800004c080000ff07000024080000520800001d080000ac0700003608000029070000ec1f0000881e0000cb200000771e000032080000b7070000f2070000900900000d09000094080000810800001e0800008a25230000000000902e2300000000006c4e22000000000054624900000000008a53220000000000ea3e2200000000003e2c220000000000de18220000000000f04c220000000000ee3a220000000000b2054300000000004e5011000000000050d6650000000000f2030000000000005037410000000000e30100000000000050a02b2000000000587eaf290000000004ece30800000000d4e9550000000000ae7c7f0000000000cabfbe0700000000b90500000000000002af120000000000d2c0170000000000ead5bf07000000009601000000000000d2280c08000000005242e201000000006b03000000000000c2e5520a000000006a36c80f00000000a2c639080000000039010000000000001302000000000000d2b3ac22000000004a010000000000002d02000000000000de0600000000000086ad210000000000a11100000000000080ad220000000000f00b000000000000487b1e0000000000fe0400000000000092fe1e0000000000fe04000000000000",
              "docs": [
                " Cost schedule and limits."
              ]
            },
            {
              "name": "SignedClaimHandicap",
              "type": "BlockNumber",
              "value": "0x02000000",
              "docs": [
                " Number of block delay an extrinsic claim surcharge has.",
                "",
                " When claim surcharge is called by an extrinsic the rent is checked",
                " for current_block - delay"
              ]
            },
            {
              "name": "TombstoneDeposit",
              "type": "BalanceOf",
              "value": "0x007a292c1c0000000000000000000000",
              "docs": [
                " The minimum amount required to generate a tombstone."
              ]
            },
            {
              "name": "DepositPerContract",
              "type": "BalanceOf",
              "value": "0x007a292c1c0000000000000000000000",
              "docs": [
                " The balance every contract needs to deposit to stay alive indefinitely.",
                "",
                " This is different from the [`Self::TombstoneDeposit`] because this only needs to be",
                " deposited while the contract is alive. Costs for additional storage are added to",
                " this base cost.",
                "",
                " This is a simple way to ensure that contracts with empty storage eventually get deleted by",
                " making them pay rent. This creates an incentive to remove them early in order to save rent."
              ]
            },
            {
              "name": "DepositPerStorageByte",
              "type": "BalanceOf",
              "value": "0x00ca9a3b000000000000000000000000",
              "docs": [
                " The balance a contract needs to deposit per storage byte to stay alive indefinitely.",
                "",
                " Let's suppose the deposit is 1,000 BU (balance units)/byte and the rent is 1 BU/byte/day,",
                " then a contract with 1,000,000 BU that uses 1,000 bytes of storage would pay no rent.",
                " But if the balance reduced to 500,000 BU and the storage stayed the same at 1,000,",
                " then it would pay 500 BU/day."
              ]
            },
            {
              "name": "DepositPerStorageItem",
              "type": "BalanceOf",
              "value": "0x00ca9a3b000000000000000000000000",
              "docs": [
                " The balance a contract needs to deposit per storage item to stay alive indefinitely.",
                "",
                " It works the same as [`Self::DepositPerStorageByte`] but for storage items."
              ]
            },
            {
              "name": "RentFraction",
              "type": "Perbill",
              "value": "0x03030000",
              "docs": [
                " The fraction of the deposit that should be used as rent per block.",
                "",
                " When a contract hasn't enough balance deposited to stay alive indefinitely it needs",
                " to pay per block for the storage it consumes that is not covered by the deposit.",
                " This determines how high this rent payment is per block as a fraction of the deposit."
              ]
            },
            {
              "name": "SurchargeReward",
              "type": "BalanceOf",
              "value": "0x00c029f73d5405000000000000000000",
              "docs": [
                " Reward that is received by the party whose touch has led",
                " to removal of a contract."
              ]
            },
            {
              "name": "DeletionQueueDepth",
              "type": "u32",
              "value": "0x0c020000",
              "docs": [
                " The maximum number of tries that can be queued for deletion."
              ]
            },
            {
              "name": "DeletionWeightLimit",
              "type": "Weight",
              "value": "0x00e8764817000000",
              "docs": [
                " The maximum amount of weight that can be consumed per block for lazy trie removal."
              ]
            }
          ],
          "errors": [
            {
              "name": "InvalidScheduleVersion",
              "docs": [
                " A new schedule must have a greater version than the current one."
              ]
            },
            {
              "name": "InvalidSurchargeClaim",
              "docs": [
                " An origin must be signed or inherent and auxiliary sender only provided on inherent."
              ]
            },
            {
              "name": "InvalidSourceContract",
              "docs": [
                " Cannot restore from nonexisting or tombstone contract."
              ]
            },
            {
              "name": "InvalidDestinationContract",
              "docs": [
                " Cannot restore to nonexisting or alive contract."
              ]
            },
            {
              "name": "InvalidTombstone",
              "docs": [
                " Tombstones don't match."
              ]
            },
            {
              "name": "InvalidContractOrigin",
              "docs": [
                " An origin TrieId written in the current block."
              ]
            },
            {
              "name": "OutOfGas",
              "docs": [
                " The executed contract exhausted its gas limit."
              ]
            },
            {
              "name": "OutputBufferTooSmall",
              "docs": [
                " The output buffer supplied to a contract API call was too small."
              ]
            },
            {
              "name": "BelowSubsistenceThreshold",
              "docs": [
                " Performing the requested transfer would have brought the contract below",
                " the subsistence threshold. No transfer is allowed to do this in order to allow",
                " for a tombstone to be created. Use `seal_terminate` to remove a contract without",
                " leaving a tombstone behind."
              ]
            },
            {
              "name": "NewContractNotFunded",
              "docs": [
                " The newly created contract is below the subsistence threshold after executing",
                " its contructor. No contracts are allowed to exist below that threshold."
              ]
            },
            {
              "name": "TransferFailed",
              "docs": [
                " Performing the requested transfer failed for a reason originating in the",
                " chosen currency implementation of the runtime. Most probably the balance is",
                " too low or locks are placed on it."
              ]
            },
            {
              "name": "MaxCallDepthReached",
              "docs": [
                " Performing a call was denied because the calling depth reached the limit",
                " of what is specified in the schedule."
              ]
            },
            {
              "name": "ContractNotFound",
              "docs": [
                " No contract was found at the specified address."
              ]
            },
            {
              "name": "ContractIsTombstone",
              "docs": [
                " A tombstone exist at the specified address.",
                "",
                " Tombstone cannot be called. Anyone can use `seal_restore_to` in order to revive",
                " the contract, though."
              ]
            },
            {
              "name": "RentNotPaid",
              "docs": [
                " The called contract does not have enough balance to pay for its storage.",
                "",
                " The contract ran out of balance and is therefore eligible for eviction into a",
                " tombstone. Anyone can evict the contract by submitting a `claim_surcharge`",
                " extrinsic. Alternatively, a plain balance transfer can be used in order to",
                " increase the contracts funds so that it can be called again."
              ]
            },
            {
              "name": "CodeTooLarge",
              "docs": [
                " The code supplied to `instantiate_with_code` exceeds the limit specified in the",
                " current schedule."
              ]
            },
            {
              "name": "CodeNotFound",
              "docs": [
                " No code could be found at the supplied code hash."
              ]
            },
            {
              "name": "OutOfBounds",
              "docs": [
                " A buffer outside of sandbox memory was passed to a contract API function."
              ]
            },
            {
              "name": "DecodingFailed",
              "docs": [
                " Input passed to a contract API function failed to decode as expected type."
              ]
            },
            {
              "name": "ContractTrapped",
              "docs": [
                " Contract trapped during execution."
              ]
            },
            {
              "name": "ValueTooLarge",
              "docs": [
                " The size defined in `T::MaxValueSize` was exceeded."
              ]
            },
            {
              "name": "TerminatedWhileReentrant",
              "docs": [
                " Termination of a contract is not allowed while the contract is already",
                " on the call stack. Can be triggered by `seal_terminate` or `seal_restore_to."
              ]
            },
            {
              "name": "InputForwarded",
              "docs": [
                " `seal_call` forwarded this contracts input. It therefore is no longer available."
              ]
            },
            {
              "name": "RandomSubjectTooLong",
              "docs": [
                " The subject passed to `seal_random` exceeds the limit."
              ]
            },
            {
              "name": "TooManyTopics",
              "docs": [
                " The amount of topics passed to `seal_deposit_events` exceeds the limit."
              ]
            },
            {
              "name": "DuplicateTopics",
              "docs": [
                " The topics passed to `seal_deposit_events` contains at least one duplicate."
              ]
            },
            {
              "name": "NoChainExtension",
              "docs": [
                " The chain does not provide a chain extension. Calling the chain extension results",
                " in this error. Note that this usually  shouldn't happen as deploying such contracts",
                " is rejected."
              ]
            },
            {
              "name": "DeletionQueueFull",
              "docs": [
                " Removal of a contract failed because the deletion queue is full.",
                "",
                " This can happen when either calling [`Pallet::claim_surcharge`] or `seal_terminate`.",
                " The queue is filled by deleting contracts and emptied by a fixed amount each block.",
                " Trying again during another block is the only way to resolve this issue."
              ]
            },
            {
              "name": "ContractNotEvictable",
              "docs": [
                " A contract could not be evicted because it has enough balance to pay rent.",
                "",
                " This can be returned from [`Pallet::claim_surcharge`] because the target",
                " contract has enough balance to pay for its rent."
              ]
            },
            {
              "name": "StorageExhausted",
              "docs": [
                " A storage modification exhausted the 32bit type that holds the storage size.",
                "",
                " This can either happen when the accumulated storage in bytes is too large or",
                " when number of storage items is too large."
              ]
            },
            {
              "name": "DuplicateContract",
              "docs": [
                " A contract with the same AccountId already exists."
              ]
            },
            {
              "name": "TerminatedInConstructor",
              "docs": [
                " A contract self destructed in its constructor.",
                "",
                " This can be triggered by a call to `seal_terminate` or `seal_restore_to`."
              ]
            },
            {
              "name": "DebugMessageInvalidUTF8",
              "docs": [
                " The debug message specified to `seal_debug_message` does contain invalid UTF-8."
              ]
            },
            {
              "name": "ReentranceDenied",
              "docs": [
                " A call tried to invoke a contract that is flagged as non-reentrant."
              ]
            }
          ],
          "index": 13
        },
        {
          "name": "Sudo",
          "storage": {
            "prefix": "Sudo",
            "items": [
              {
                "name": "Key",
                "modifier": "Default",
                "type": {
                  "plain": "AccountId"
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "docs": [
                  " The `AccountId` of the sudo key."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "sudo",
              "args": [
                {
                  "name": "call",
                  "type": "Call"
                }
              ],
              "docs": [
                " Authenticates the sudo key and dispatches a function call with `Root` origin.",
                "",
                " The dispatch origin for this call must be _Signed_.",
                "",
                " # <weight>",
                " - O(1).",
                " - Limited storage reads.",
                " - One DB write (event).",
                " - Weight of derivative `call` execution + 10,000.",
                " # </weight>"
              ]
            },
            {
              "name": "sudo_unchecked_weight",
              "args": [
                {
                  "name": "call",
                  "type": "Call"
                },
                {
                  "name": "_weight",
                  "type": "Weight"
                }
              ],
              "docs": [
                " Authenticates the sudo key and dispatches a function call with `Root` origin.",
                " This function does not check the weight of the call, and instead allows the",
                " Sudo user to specify the weight of the call.",
                "",
                " The dispatch origin for this call must be _Signed_.",
                "",
                " # <weight>",
                " - O(1).",
                " - The weight of this call is defined by the caller.",
                " # </weight>"
              ]
            },
            {
              "name": "set_key",
              "args": [
                {
                  "name": "new",
                  "type": "LookupSource"
                }
              ],
              "docs": [
                " Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.",
                "",
                " The dispatch origin for this call must be _Signed_.",
                "",
                " # <weight>",
                " - O(1).",
                " - Limited storage reads.",
                " - One DB change.",
                " # </weight>"
              ]
            },
            {
              "name": "sudo_as",
              "args": [
                {
                  "name": "who",
                  "type": "LookupSource"
                },
                {
                  "name": "call",
                  "type": "Call"
                }
              ],
              "docs": [
                " Authenticates the sudo key and dispatches a function call with `Signed` origin from",
                " a given account.",
                "",
                " The dispatch origin for this call must be _Signed_.",
                "",
                " # <weight>",
                " - O(1).",
                " - Limited storage reads.",
                " - One DB write (event).",
                " - Weight of derivative `call` execution + 10,000.",
                " # </weight>"
              ]
            }
          ],
          "events": [
            {
              "name": "Sudid",
              "args": [
                "DispatchResult"
              ],
              "docs": [
                " A sudo just took place. \\[result\\]"
              ]
            },
            {
              "name": "KeyChanged",
              "args": [
                "AccountId"
              ],
              "docs": [
                " The \\[sudoer\\] just switched identity; the old key is supplied."
              ]
            },
            {
              "name": "SudoAsDone",
              "args": [
                "DispatchResult"
              ],
              "docs": [
                " A sudo just took place. \\[result\\]"
              ]
            }
          ],
          "constants": [],
          "errors": [
            {
              "name": "RequireSudo",
              "docs": [
                " Sender must be the Sudo account"
              ]
            }
          ],
          "index": 14
        }
      ],
      "extrinsic": {
        "version": 4,
        "signedExtensions": [
          "CheckSpecVersion",
          "CheckTxVersion",
          "CheckGenesis",
          "CheckMortality",
          "CheckNonce",
          "CheckWeight",
          "ChargeTransactionPayment"
        ]
      }
    }
  }
}